# VAI TRÒ & NGÔN NGỮ

## VAI TRÒ
Bạn là một chuyên gia lập trình Flutter/Dart cao cấp, chuyên về kiến trúc mã nguồn sạch (Clean Code) và tối ưu hóa hiệu suất giao diện Mobile.

## NGÔN NGỮ
Hãy phản hồi lại tôi bằng tiếng Việt.

---

# ⚠️ FILE TRUNG TÂM ĐIỀU PHỐI

**File này (`.clinerules`) là file TRUNG TÂM điều phối tất cả quy tắc và hướng dẫn trong dự án.**

**Cấu trúc điều phối:**
- `.clinerules` → Reference đến các file docs chính
- `docs/ai/AI_INSTRUCTIONS.md` → Core instructions cho AI agents
- `docs/DOCS_STRUCTURE.md` → Cấu trúc documentation
- `memory-bank/` → Context và memory cho AI agents

**Quy tắc:**
- ✅ Tất cả quy tắc chính nằm trong `.clinerules`
- ✅ Chi tiết kỹ thuật → Reference đến `docs/ai/AI_INSTRUCTIONS.md`
- ✅ Cấu trúc docs → Reference đến `docs/DOCS_STRUCTURE.md`
- ✅ Context dự án → Reference đến `memory-bank/`

---

# QUY TẮC CỐT LÕI
Cho phép tự động sử dụng các MCP Fetch, Context7

## Mandatory Context Reading Protocol

### Quy tắc BẮT BUỘC đọc tài liệu trước khi hành động:
- **KHI NÀO:** Mỗi khi nhận lệnh từ người dùng, PHẢI đọc lại các tài liệu liên quan TRƯỚC KHI thực hiện
- **PHÂN LOẠI TASK:** Xác định category của task để đọc đúng tài liệu:
  - **UI/Giao diện** → Đọc `memory-bank/DESIGN_SYSTEM_GUIDE.md` + `memory-bank/systemPatterns.md` (Design System section)
  - **Database/Repository** → Đọc `memory-bank/systemPatterns.md` (Data Layer) + `docs/ai/README_SUPABASE.md`
  - **State Management** → Đọc `memory-bank/systemPatterns.md` (State Management) + `.cursor/.cursorrules` (Tech Stack)
  - **Architecture** → Đọc `docs/ai/AI_INSTRUCTIONS.md` (Section 2) + `memory-bank/systemPatterns.md` (Architecture)
  - **Thư viện mới** → Sử dụng MCP Fetch để đọc documentation từ pub.dev
- **WORKFLOW:**
  1. Nhận lệnh từ người dùng
  2. Phân tích và xác định category (UI/Database/State/Architecture/Library)
  3. Đọc tài liệu liên quan từ memory-bank hoặc docs (sử dụng `read_file` tool)
  4. Kiểm tra patterns hiện tại trong codebase (sử dụng `codebase_search` hoặc `grep`)
  5. Thực hiện task theo đúng patterns và standards đã đọc
  6. Cập nhật memory-bank nếu có thay đổi quan trọng

### Quy tắc BẮT BUỘC tuân thủ nguyên tắc giao diện:
- **KHI NÀO:** Khi sửa bất kỳ file nào liên quan đến UI/giao diện (files trong `lib/presentation/views/`, `lib/widgets/`)
- **BẮT BUỘC:**
  1. Đọc `memory-bank/DESIGN_SYSTEM_GUIDE.md` trước khi sửa
  2. Đọc `lib/core/constants/design_tokens.dart` để xem tokens có sẵn
  3. Tuân thủ Design Tokens (màu sắc, spacing, typography, icons, radius, shadows)
  4. Tuân thủ Component Standards (button heights, input heights, card sizes, etc.)
  5. Sử dụng `flutter_screenutil` cho responsive design
  6. Đảm bảo accessibility (contrast, touch targets)
  7. Sử dụng `keyboardDismissBehavior` cho ScrollView
- **KHÔNG ĐƯỢC:**
  - Hardcode màu sắc, spacing, font sizes
  - Bỏ qua Design Tokens
  - Tạo custom sizes không tuân thủ standards
  - Bỏ qua responsive design

### Quy tắc BẮT BUỘC sử dụng MCP khi được yêu cầu:
- **KHI NÀO:** Khi người dùng yêu cầu sử dụng MCP (ví dụ: "dùng MCP Fetch", "sử dụng MCP", "check bằng MCP", "đọc documentation bằng MCP")
- **BẮT BUỘC:** PHẢI sử dụng MCP tools ngay lập tức, không được bỏ qua
- **CÁC LOẠI MCP:**
  - **MCP Fetch:** Đọc documentation của thư viện mới, best practices từ web
  - **Supabase MCP:** Kiểm tra schema, query data, apply migrations
  - **Context7 MCP:** Tìm patterns trong codebase
  - **Dart MCP:** Format code, analyze linter errors, kiểm tra code quality
  - **GitHub MCP:** Git operations (chỉ khi được yêu cầu rõ ràng)
- **ƯU TIÊN:** Luôn ưu tiên MCP khi người dùng yêu cầu, không được tự ý bỏ qua

### Quy tắc BẮT BUỘC sử dụng thư viện phù hợp:
- **KHI NÀO:** Khi người dùng yêu cầu implement feature hoặc sử dụng thư viện
- **BẮT BUỘC:** PHẢI sử dụng thư viện đã được định nghĩa trong `.cursor/.cursorrules` (Tech Stack Standards)
- **THƯ VIỆN BẮT BUỘC:**
  - **QR Code:** `QrHelper` từ `lib/core/utils/qr_helper.dart` (wraps `pretty_qr_code`)
  - **Routing:** `go_router` cho routing mới
  - **State Management:** Riverpod với `@riverpod` generator
  - **Models:** `freezed` + `json_serializable`
  - **Networking:** `dio` + `retrofit`
  - **Local Storage:** `drift` (relational) + `flutter_secure_storage` (tokens)
  - **Responsive UI:** `flutter_screenutil`
  - **Logging:** `logger` package (sẽ có `AppLogger` wrapper)
  - **Error Reporting:** `sentry_flutter`
- **NẾU THƯ VIỆN CHƯA CÓ:** Hỏi người dùng hoặc đề xuất từ tech stack, không tự ý thêm thư viện mới

## Database & MCP

### Quy tắc làm việc với Database & MCP:
- Trước khi thực hiện bất kỳ lệnh nào liên quan đến Database (Query, tạo Model, viết Repo), LUÔN LUÔN sử dụng MCP để kiểm tra cấu trúc bảng thực tế.
- Không tự ý giả định tên cột (ví dụ: không mặc định có cột 'created_at' trừ khi đã kiểm tra).
- Khi người dùng yêu cầu "xem" hoặc "lấy" dữ liệu, hãy dùng `execute_query` để hiển thị trực tiếp, không tạo file mới trừ khi được yêu cầu.
- Khi cần ghi note hay dữ liệu cần thiết thì ghi vào file README_SUPABASE.md

## Docs & Memory Prompt

### Quy tắc đọc docs trước khi hành động:
- **BẮT BUỘC:** Đọc `docs/DOCS_STRUCTURE.md` để hiểu cấu trúc thư mục và quy tắc đặt tên trước khi tạo file markdown mới.
- Trước khi tạo/cập nhật tài liệu Markdown trong repo: phải đọc `docs/ai/DOCS_PROMPT_RULES.md`.

### Quy tắc tạo file markdown mới:
- **Xác định loại file:**
  - AI Agent doc → `docs/ai/`
  - Developer guide → `docs/guides/development/`
  - Feature doc → `docs/guides/features/{feature-name}/`
  - Tool guide → `docs/guides/tools/`
  - Report → `docs/reports/`
- **Đặt tên:** Sử dụng kebab-case (ví dụ: `quick-reference.md`, `testing-guide.md`)
- **Cập nhật `docs/DOCS_STRUCTURE.md`:** Sau khi tạo file mới, **BẮT BUỘC** cập nhật file `docs/DOCS_STRUCTURE.md`:
  - Thêm file vào bảng tương ứng
  - Mô tả mục đích và khi nào đọc
  - Cập nhật thống kê nếu cần
- **Cập nhật index (nếu là feature doc):** Nếu tạo file trong `docs/guides/features/{feature-name}/`, cập nhật `index.md` trong folder đó

### Quy tắc sử dụng MCP Servers:
- **Supabase MCP**: Sử dụng để query database, kiểm tra schema, apply migrations, xem logs, và quản lý edge functions. Luôn kiểm tra schema trước khi tạo model hoặc repository.
- **Fetch MCP**: Sử dụng để fetch documentation, examples từ web khi cần tìm hiểu về thư viện mới hoặc best practices.
- **Context7 MCP**: Sử dụng để quản lý context và tìm kiếm thông tin trong codebase.
- **GitHub MCP**: Sử dụng để quản lý Git operations như tạo commits, xem branches, tạo PRs. Chỉ sử dụng khi được yêu cầu rõ ràng.
- **Filesystem MCP**: Sử dụng để đọc/ghi files, navigate codebase khi cần truy cập nhiều files cùng lúc hoặc tìm kiếm patterns.
- **Dart MCP**: Sử dụng để phân tích code Dart/Flutter, format code, kiểm tra linter errors, và các operations liên quan đến Dart tooling.

#### Quy tắc sử dụng Dart MCP:

**KHI NÀO NÊN SỬ DỤNG Dart MCP:**

1. **Format code tự động:**
   - Khi cần format một file hoặc nhiều files Dart
   - Khi code chưa được format đúng chuẩn Dart style
   - Ví dụ: "Sử dụng Dart MCP để format file lib/presentation/views/home_screen.dart"

2. **Phân tích linter errors:**
   - Khi cần kiểm tra linter errors trong một file hoặc thư mục cụ thể
   - Khi muốn xem chi tiết warnings/errors trước khi fix
   - Ví dụ: "Sử dụng Dart MCP để analyze linter errors trong lib/presentation/"

3. **Kiểm tra code quality:**
   - Khi cần đánh giá code quality của một phần code
   - Khi muốn tìm các vấn đề tiềm ẩn trong code
   - Ví dụ: "Sử dụng Dart MCP để kiểm tra code quality của file lib/data/repositories/"

4. **Tìm kiếm patterns trong code Dart:**
   - Khi cần tìm các patterns cụ thể trong codebase Dart
   - Khi muốn phân tích cấu trúc code Dart
   - Ví dụ: "Sử dụng Dart MCP để tìm tất cả các class extends ChangeNotifier"

**KHI NÀO KHÔNG CẦN SỬ DỤNG Dart MCP:**

1. **Đọc file đơn giản:**
   - KHÔNG sử dụng Dart MCP để đọc file, dùng `read_file` tool thay thế
   - `read_file` tool nhanh hơn và phù hợp hơn cho việc đọc file

2. **Tìm kiếm text đơn giản:**
   - KHÔNG sử dụng Dart MCP để tìm kiếm text trong files, dùng `grep` tool thay thế
   - `grep` tool hiệu quả hơn cho text search

3. **Semantic search:**
   - KHÔNG sử dụng Dart MCP cho semantic search, dùng `codebase_search` tool thay thế
   - `codebase_search` tool phù hợp hơn cho tìm kiếm theo ngữ nghĩa

4. **Operations đơn giản:**
   - KHÔNG sử dụng Dart MCP cho các operations đơn giản có thể dùng tools khác
   - Chỉ sử dụng khi thực sự cần phân tích code Dart hoặc format code

**CÁCH SỬ DỤNG Dart MCP:**

1. **Format code:**
   ```
   Sử dụng Dart MCP để format file [đường dẫn file]
   ```

2. **Analyze linter:**
   ```
   Sử dụng Dart MCP để analyze linter errors trong [file hoặc thư mục]
   ```

3. **Code quality check:**
   ```
   Sử dụng Dart MCP để kiểm tra code quality của [file hoặc thư mục]
   ```

**Best Practices:**
- Sử dụng Dart MCP sau khi viết code để đảm bảo code quality
- Kết hợp với `flutter analyze` và `dart format` commands khi cần
- Không lạm dụng Dart MCP cho các operations đơn giản
- Ưu tiên sử dụng built-in tools (`read_file`, `grep`, `codebase_search`) trước khi dùng Dart MCP

> **Xem thêm:** Chi tiết về MCP Usage Patterns trong `docs/ai/AI_INSTRUCTIONS.md` (Section 10) và `memory-bank/techContext.md` (MCP Setup section)

## Context Reading & Documentation Protocol

### Quy tắc đọc tài liệu trước khi hành động:
- **BẮT BUỘC:** Khi nhận bất kỳ lệnh nào từ người dùng, PHẢI đọc lại các tài liệu liên quan trước khi thực hiện:
  - Nếu liên quan đến **UI/Giao diện**: Đọc `memory-bank/DESIGN_SYSTEM_GUIDE.md` và `memory-bank/systemPatterns.md` (Design System section)
  - Nếu liên quan đến **Database/Repository**: Đọc `memory-bank/systemPatterns.md` (Data Layer section) và `docs/ai/README_SUPABASE.md`
  - Nếu liên quan đến **State Management**: Đọc `memory-bank/systemPatterns.md` (State Management section) và `.cursor/.cursorrules` (Tech Stack section)
  - Nếu liên quan đến **Architecture**: Đọc `docs/ai/AI_INSTRUCTIONS.md` (Section 2) và `memory-bank/systemPatterns.md` (Overall Architecture section)
  - Nếu liên quan đến **Thư viện mới**: Sử dụng MCP Fetch để đọc documentation từ pub.dev trước khi implement
- **Workflow chuẩn:**
  1. Phân tích lệnh của người dùng → Xác định category (UI/Database/State/Architecture)
  2. Đọc tài liệu liên quan từ memory-bank hoặc docs
  3. Kiểm tra patterns hiện tại trong codebase
  4. Thực hiện task theo đúng patterns và standards
  5. Cập nhật memory-bank nếu có thay đổi quan trọng

### Quy tắc sử dụng MCP khi được yêu cầu:
- **BẮT BUỘC:** Khi người dùng yêu cầu sử dụng MCP (ví dụ: "dùng MCP Fetch", "sử dụng MCP", "check bằng MCP"), PHẢI sử dụng MCP tools ngay lập tức
- **MCP Fetch:** Sử dụng khi cần đọc documentation của thư viện mới hoặc best practices từ web
- **Supabase MCP:** Sử dụng khi cần kiểm tra schema, query data, apply migrations
- **Context7 MCP:** Sử dụng khi cần tìm patterns trong codebase
- **Dart MCP:** Sử dụng khi cần format code, analyze linter errors, kiểm tra code quality
- **Luôn ưu tiên MCP** khi người dùng yêu cầu rõ ràng, không được bỏ qua

### Quy tắc sử dụng thư viện phù hợp:
- **BẮT BUỘC:** Khi người dùng yêu cầu implement feature, PHẢI sử dụng thư viện đã được định nghĩa trong `.cursor/.cursorrules` (Tech Stack Standards)
- **QR Code:** Luôn sử dụng `QrHelper` từ `lib/core/utils/qr_helper.dart` (wraps `pretty_qr_code`)
- **Routing:** Sử dụng `go_router` cho routing mới (migration từ AppRoutes đang trong tiến trình)
- **State Management:** Ưu tiên Riverpod với `@riverpod` generator cho features mới
- **Models:** Sử dụng `freezed` + `json_serializable` cho tất cả domain entities
- **Networking:** Sử dụng `dio` + `retrofit` cho external API calls
- **Local Storage:** Sử dụng `drift` cho relational data, `flutter_secure_storage` cho tokens
- **Responsive UI:** Sử dụng `flutter_screenutil` cho responsive design
- **Logging:** Sử dụng `logger` package (sẽ có `AppLogger` wrapper)
- **Error Reporting:** Tích hợp `sentry_flutter` cho error tracking
- **Nếu thư viện chưa có trong tech stack:** Hỏi người dùng trước khi thêm, hoặc đề xuất thư viện phù hợp từ tech stack

## Flutter Architecture (MVVM & Clean Architecture)

### Quy tắc Flutter:
- Luôn tuân thủ cấu trúc MVVM.
- Repository phải nằm trong thư mục 'domain/repositories'.
- Không tạo file mới trừ khi được yêu cầu.
- Trước khi hành động thì hãy vào file `docs/ai/AI_INSTRUCTIONS.md` đọc và phân tích trong đó rồi tiếp tục các bước
- Mỗi khi tôi thêm một thư viện mới vào pubspec.yaml, hãy dùng MCP Fetch để tìm ví dụ (Example) của thư viện đó trước khi viết code cho tôi.
- Khi tạo file mới phải tuân thủ quy tắc tạo file trong `docs/ai/AI_INSTRUCTIONS.md`
- Các Widget có thể sử dụng nhiều lần hãy tách thành 1 hàm ghi vào 1 class để dễ lấy ra sử dụng lại nhất là khi sử dụng giao diện.

> **Xem thêm:** Chi tiết về Clean Architecture và MVVM patterns trong `docs/ai/AI_INSTRUCTIONS.md` (Section 2) và `memory-bank/systemPatterns.md` (Overall Architecture section)

## Code Quality

### Quy tắc Code Quality:
- Tuân thủ nghiêm ngặt Dart/Flutter style guide và các rules trong `analysis_options.yaml`.
- Code phải được format bằng `dart format` trước khi commit.
- Tất cả warnings từ `flutter analyze` phải được xử lý, không được ignore trừ khi có lý do chính đáng.
- Functions không được quá 50 dòng, nếu vượt quá phải tách thành các functions nhỏ hơn.
- Classes không được quá 300 dòng, nếu vượt quá phải refactor hoặc tách thành các classes nhỏ hơn.
- Luôn sử dụng const constructor khi có thể để tối ưu performance.
- Tránh hardcode values, sử dụng constants từ `core/constants/`.
- Error handling phải rõ ràng, không được bỏ qua exceptions mà không xử lý.

> **Xem thêm:** Chi tiết về code conventions trong `memory-bank/activeContext.md` (Active Preferences & Standards section)

---

# QUY TẮC CHUYÊN BIỆT

## Git Workflow

### Quy tắc Git Workflow:
- Luôn commit với message rõ ràng, mô tả ngắn gọn những gì đã thay đổi.
- Commit message format: `[type] description` (ví dụ: `[feat] Add assignment builder screen`, `[fix] Fix auth state management`, `[refactor] Extract drawer components`).
- Một commit chỉ nên chứa một thay đổi logic hoàn chỉnh, không commit nhiều features không liên quan.
- Trước khi commit, kiểm tra lại code bằng `flutter analyze` và đảm bảo không có lỗi nghiêm trọng.
- Không commit các file tạm, file build, hoặc file cấu hình cá nhân (đã được ignore trong .gitignore).

## HTML → Dart Conversion

### QUY TẮC CHUYỂN ĐỔI HTML SANG DART

#### Ánh xạ HTML → Widget Dart

##### Thành phần HTML cơ bản → Widget Dart
- `<div>` → `Container` hoặc `Column`/`Row` (tùy thuộc vào layout)
- `<span>` → `Text` hoặc `RichText` (nếu có định dạng phức tạp)
- `<button>` → `ElevatedButton`, `TextButton`, hoặc `IconButton`
- `<input>` → `TextField` hoặc `TextFormField`
- `<img>` → `Image.network`, `Image.asset`, hoặc `CircleAvatar`
- `<a>` → `TextButton` hoặc `InkWell` với `onTap`
- `<ul>/<ol>` → `ListView` hoặc `Column` với các `ListTile`
- `<li>` → `ListTile` hoặc widget tùy chỉnh
- `<table>` → `DataTable` hoặc `Column`/`Row` lồng nhau
- `<form>` → `Form` widget với `TextFormField` và validation

##### Layout và Container
- `<div class="container">` → `Container` với padding/margin phù hợp
- `<div class="row">` → `Row` với `mainAxisAlignment` và `crossAxisAlignment`
- `<div class="column">` → `Column` với `mainAxisAlignment` và `crossAxisAlignment`
- `<div class="flex">` → `Flex` với `direction` phù hợp
- `<div class="grid">` → `GridView.count` hoặc `GridView.builder`

##### Form và Input
- `<form>` → `Form` widget với `GlobalKey<FormState>`
- `<input type="text">` → `TextFormField` với `validator`
- `<input type="password">` → `TextFormField` với `obscureText: true`
- `<input type="email">` → `TextFormField` với `keyboardType: TextInputType.emailAddress`
- `<input type="checkbox">` → `Checkbox` hoặc `CheckboxListTile`
- `<input type="radio">` → `Radio` hoặc `RadioListTile`
- `<select>` → `DropdownButton` hoặc `DropdownButtonFormField`
- `<textarea>` → `TextFormField` với `maxLines: null`

##### Hiển thị và Style
- `class="hidden"` → `Visibility` widget với `visible: false`
- `style="color: #ff0000"` → `TextStyle(color: Colors.red)`
- `style="font-size: 16px"` → `TextStyle(fontSize: 16)`
- `style="font-weight: bold"` → `TextStyle(fontWeight: FontWeight.bold)`
- `style="background-color: #f0f0f0"` → `Container(color: Colors.grey[200])`
- `style="padding: 16px"` → `Padding(padding: EdgeInsets.all(16))`
- `style="margin: 8px 0"` → `Container(margin: EdgeInsets.symmetric(vertical: 8))`

#### Tách Widget và Tổ chức Code

##### Nguyên tắc tách Widget
1. **Tái sử dụng**: Nếu một thành phần được sử dụng nhiều lần → Tách thành widget riêng
2. **Phức tạp**: Nếu một phần có logic phức tạp → Tách thành widget riêng
3. **Dài dòng**: Nếu hàm build quá 50 dòng → Tách thành các widget con
4. **Logic riêng biệt**: Nếu một phần có trạng thái hoặc logic riêng → Tách thành widget riêng

##### Cấu trúc Widget
```dart
// Widget đơn giản (dưới 50 dòng)
Widget _buildHeader(BuildContext context) {
  return Container(
    // Nội dung widget
  );
}

// Widget phức tạp (trên 50 dòng hoặc tái sử dụng)
class CustomHeader extends StatelessWidget {
  final String title;
  final String subtitle;

  const CustomHeader({
    super.key,
    required this.title,
    required this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      // Nội dung widget phức tạp
    );
  }
}
```

##### Đặt tên Widget
- Widget con trong cùng file: `_buildHeader()`, `_buildFooter()`
- Widget riêng biệt: `CustomHeader()`, `UserProfileCard()`
- Widget tái sử dụng: `ReusableButton()`, `InputField()`

#### Widget Custom vs Widget Chuẩn Flutter

##### Widget Chuẩn Flutter
- `Container`, `Column`, `Row`, `Text`, `Image`, `Icon`
- `ElevatedButton`, `TextButton`, `IconButton`
- `TextField`, `TextFormField`, `DropdownButton`
- `ListView`, `GridView`, `ListTile`
- `Card`, `Chip`, `Badge`
- `AppBar`, `BottomNavigationBar`, `Drawer`
- `AlertDialog`, `BottomSheet`, `SnackBar`

##### Widget Custom trong Dự án
- `ClassItemWidget`: Hiển thị thông tin lớp học
- `ClassStatusBadge`: Hiển thị trạng thái lớp học
- `SearchField`: Trường tìm kiếm tùy chỉnh
- `SmartMarqueeText`: Text cuộn thông minh
- `ActionEndDrawer`: Drawer tùy chỉnh
- `DrawerActionTile`: Tile hành động trong drawer
- `DrawerToggleTile`: Tile toggle trong drawer
- `TeacherAssignmentList`: Danh sách bài tập của giáo viên

#### Cấu trúc Code Hoàn chỉnh

##### Import và Main
```dart
import 'package:flutter/material.dart';
import 'package:ai_mls/core/constants/design_tokens.dart';
import 'package:ai_mls/widgets/custom_widgets.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'AI LMS',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        fontFamily: 'Roboto',
      ),
      home: const HomeScreen(),
    );
  }
}
```

##### Scaffold và Layout
```dart
class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Trang chủ'),
        actions: [
          IconButton(
            icon: const Icon(Icons.search),
            onPressed: () {},
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          children: [
            _buildHeader(),
            _buildContent(),
            _buildFooter(),
          ],
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: 'Trang chủ',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.settings),
            label: 'Cài đặt',
          ),
        ],
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: EdgeInsets.all(DesignSpacing.lg),
      child: const Text(
        'Chào mừng bạn đến với AI LMS',
        style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
      ),
    );
  }

  Widget _buildContent() {
    return Padding(
      padding: EdgeInsets.all(DesignSpacing.md),
      child: Column(
        children: [
          // Nội dung chính
        ],
      ),
    );
  }

  Widget _buildFooter() {
    return Container(
      padding: EdgeInsets.all(DesignSpacing.lg),
      child: const Text('© 2026 AI LMS'),
    );
  }
}
```

#### Yêu cầu Đầu ra

##### Giải thích ngắn sau khi viết code
```markdown
## Giải thích chuyển đổi

### Ánh xạ HTML → Widget
- `<div class="header">` → `Container` với padding và màu nền
- `<h1>Chào mừng</h1>` → `Text` với style `DesignTypography.titleLarge`
- `<button class="primary">Đăng nhập</button>` → `ElevatedButton` với `style: ElevatedButton.styleFrom(primary: DesignColors.primary)`

### Lý do tách widget
- `_buildHeader()`: Tách riêng vì được sử dụng lại trong nhiều màn hình
- `_buildUserCard()`: Tách riêng vì có logic phức tạp và tái sử dụng
- `CustomInputField()`: Tách riêng vì được sử dụng nhiều lần với các tham số khác nhau

### Widget custom vs widget chuẩn
- Widget chuẩn: `Container`, `Text`, `ElevatedButton`, `Column`, `Row`
- Widget custom: `CustomInputField`, `UserProfileCard`, `ClassItemWidget`
```

##### Kết quả đầu ra hoàn chỉnh
- Code Dart hoàn chỉnh với tất cả import cần thiết
- Hàm `main()` và `MaterialApp` hoàn chỉnh
- Cấu trúc `Scaffold` đầy đủ với `appBar`, `body`, `bottomNavigationBar`
- Không sử dụng dấu "..." (code phải hoàn chỉnh và chạy được)
- Không bỏ sót bất kỳ phần HTML nào (trừ khi có lệnh bỏ cụ thể)
- Code có thể copy và chạy ngay trong Flutter

##### Ví dụ Minh họa

###### HTML đầu vào
```html
<div class="user-card">
  <img src="avatar.jpg" class="avatar">
  <div class="user-info">
    <h3>John Doe</h3>
    <p>john@example.com</p>
  </div>
  <button class="follow-btn">Follow</button>
</div>
```

###### Dart đầu ra
```dart
class UserCard extends StatelessWidget {
  final String name;
  final String email;
  final String avatarUrl;
  final VoidCallback onFollow;

  const UserCard({
    super.key,
    required this.name,
    required this.email,
    required this.avatarUrl,
    required this.onFollow,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.all(DesignSpacing.lg),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(DesignRadius.md),
        boxShadow: [DesignElevation.level1],
      ),
      child: Row(
        children: [
          CircleAvatar(
            radius: 24,
            backgroundImage: NetworkImage(avatarUrl),
          ),
          SizedBox(width: DesignSpacing.md),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  name,
                  style: DesignTypography.titleMedium,
                ),
                SizedBox(height: DesignSpacing.xs),
                Text(
                  email,
                  style: DesignTypography.bodySmall,
                ),
              ],
            ),
          ),
          ElevatedButton(
            onPressed: onFollow,
            style: ElevatedButton.styleFrom(
              padding: EdgeInsets.symmetric(horizontal: DesignSpacing.md),
            ),
            child: const Text('Follow'),
          ),
        ],
      ),
    );
  }
}
```

###### Giải thích
```markdown
## Giải thích chuyển đổi

### Ánh xạ HTML → Widget
- `<div class="user-card">` → `Container` với padding và decoration
- `<img src="avatar.jpg" class="avatar">` → `CircleAvatar` với `backgroundImage`
- `<div class="user-info">` → `Expanded` với `Column` bên trong
- `<h3>John Doe</h3>` → `Text` với `DesignTypography.titleMedium`
- `<p>john@example.com</p>` → `Text` với `DesignTypography.bodySmall`
- `<button class="follow-btn">Follow</button>` → `ElevatedButton`

### Lý do tách widget
- `UserCard` được tách thành widget riêng vì:
  - Được sử dụng lại trong nhiều màn hình
  - Có cấu trúc phức tạp với nhiều thành phần con
  - Dễ dàng quản lý và bảo trì

### Widget custom vs widget chuẩn
- Widget chuẩn: `Container`, `Row`, `Column`, `Text`, `CircleAvatar`, `ElevatedButton`
- Widget custom: `UserCard` (widget mới được tạo)
```

## UI/Interface Rules

### QUY TẮC TUÂN THỦ NGUYÊN TẮC GIAO DIỆN
Khi sửa file liên quan đến giao diện (UI), bạn PHẢI tuân thủ nghiêm ngặt các quy tắc sau:

1. **BẮT BUỘC đọc Design System trước khi sửa UI:**
   - Đọc `memory-bank/DESIGN_SYSTEM_GUIDE.md` để hiểu design tokens và component standards
   - Đọc `memory-bank/systemPatterns.md` (Design System Specifications section)
   - Kiểm tra `lib/core/constants/design_tokens.dart` để xem các tokens có sẵn

2. **Tuân thủ Design Tokens:**
   - **Màu sắc:** LUÔN sử dụng `DesignColors.*` từ `design_tokens.dart`, KHÔNG hardcode màu
   - **Spacing:** LUÔN sử dụng `DesignSpacing.*` (xs, sm, md, lg, xl, etc.), KHÔNG hardcode spacing
   - **Typography:** LUÔN sử dụng `DesignTypography.*` TextStyle objects, KHÔNG tạo custom font sizes
   - **Icons:** LUÔN sử dụng `DesignIcons.*` constants cho icon sizes
   - **Border Radius:** LUÔN sử dụng `DesignRadius.*` tokens
   - **Shadows:** LUÔN sử dụng `DesignElevation.level*` cho shadows
   - **Component Sizes:** Tham khảo `DesignComponents.*` trong design_tokens.dart

3. **Responsive Design:**
   - Sử dụng `flutter_screenutil` cho responsive sizing
   - Sử dụng `DesignBreakpoints` để kiểm tra device type (mobile/tablet/desktop)
   - Tuân thủ responsive breakpoints đã định nghĩa trong design system

4. **Component Standards:**
   - Button height: 44dp (medium), 36dp (small), 52dp (large)
   - Input field height: 48dp (đã giảm từ 56dp)
   - Card min height: 100dp (đã giảm từ 120dp)
   - AppBar height: 56dp (Material standard)
   - Touch targets: Minimum 48×48dp

5. **Accessibility:**
   - Đảm bảo contrast ratio ≥ 4.5:1 cho text
   - Touch targets ≥ 48×48dp
   - Sử dụng semantic labels cho screen readers

6. **Widget Organization:**
   - Tách widget thành các methods/classes nhỏ (< 50 dòng mỗi method)
   - Sử dụng `const` constructors khi có thể
   - Tái sử dụng widgets từ `lib/widgets/` khi có thể

7. **Keyboard & Scroll Behavior:**
   - Luôn sử dụng `keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag` cho ScrollView
   - Dismiss keyboard khi scroll

8. **State Preservation:**
   - Sử dụng `AutomaticKeepAliveClientMixin` cho screens cần preserve state
   - Sử dụng `AutomaticKeepAliveClientMixin` cho tabs trong TabBarView

> **Xem thêm:** 
> - Chi tiết Design System: `memory-bank/DESIGN_SYSTEM_GUIDE.md`
> - Design Tokens: `lib/core/constants/design_tokens.dart`
> - Component Patterns: `memory-bank/systemPatterns.md` (Design System Specifications section)

## Flutter Refactoring

### QUY TẮC VIẾT CODE (FLUTTER REFACTORING)
Khi tạo hoặc chỉnh sửa giao diện (UI), bạn PHẢI tuân thủ các quy tắc sau:

1. **NGUYÊN TẮC TÁCH NHỎ (MODULARIZATION):**
   - Không được viết quá 50 dòng code trong một hàm build() duy nhất.
   - Các khối giao diện logic (Header, Body, Footer, Card item,...) phải được tách thành các hàm private (ví dụ: Widget _buildHeader()) hoặc các class StatelessWidget riêng biệt.
   - Nếu một Widget được tái sử dụng trên 2 lần, bắt buộc phải tách thành một file Component riêng.

2. **CẤU TRÚC HÀM:**
   - Ưu tiên sử dụng 'Getter' hoặc 'Methods' cho các Widget nhỏ đơn giản.
   - Sử dụng 'StatelessWidget' cho các thành phần phức tạp để tối ưu hóa việc rebuild của Flutter.

3. **ĐẶT TÊN (NAMING CONVENTION):**
   - Tên hàm tách ra phải bắt đầu bằng '_build' (ví dụ: _buildSubmitButton, _buildInputField).
   - Tên biến phải rõ ràng, tránh đặt tên chung chung như 'data', 'container'.

4. **QUY TẮC UI/UX:**
   - Luôn sử dụng Const constructor ở những nơi có thể để tối ưu RAM.
   - Đảm bảo xử lý tràn viền (Overflow) bằng Wrap hoặc SingleChildScrollView.

### ĐỊNH DẠNG PHẢN HỒI
- Trước khi viết code, hãy tóm tắt ngắn gọn danh sách các hàm/component bạn định tách ra.
- Sau khi viết code, giải thích lý do tại sao cấu trúc này dễ quản lý hơn.

## Drawer System

### Cấu trúc thư mục mới cho Drawer System
```
lib/widgets/
├── drawers/
│   ├── action_end_drawer.dart        # Khung chung cho drawer
│   ├── class_settings_drawer.dart    # Nội dung cụ thể cho lớp học
│   ├── drawer_section_header.dart    # Header cho các section
│   ├── drawer_action_tile.dart       # Tile hành động
│   └── drawer_toggle_tile.dart      # Tile toggle (switch)
```

### Cách sử dụng Drawer System
1. **Tạo drawer mới**: Tạo file trong `lib/widgets/drawers/` với nội dung cụ thể
2. **Sử dụng ActionEndDrawer**: Là khung chung cho tất cả drawer
3. **Tích hợp vào màn hình**: Sử dụng `Scaffold.endDrawer` và `Scaffold.of(context).openEndDrawer()`

### Ví dụ sử dụng
```dart
Scaffold(
  endDrawer: ActionEndDrawer(
    title: 'Tùy chọn Lớp học',
    subtitle: className,
    child: ClassSettingsDrawer(
      className: className,
      semesterInfo: semesterInfo,
      pendingStudentRequests: 3,
    ),
  ),
  body: Builder(
    builder: (context) => IconButton(
      icon: Icon(Icons.more_vert),
      onPressed: () => Scaffold.of(context).openEndDrawer(),
    ),
  ),
)
```

### Quy tắc cho Drawer
- Luôn sử dụng ActionEndDrawer làm khung chung
- Mỗi drawer nội dung phải là StatelessWidget riêng biệt
- Sử dụng DrawerActionTile và DrawerToggleTile cho các mục hành động
- Đảm bảo drawer width = 340px cho nhất quán
- Sử dụng DesignTokens cho màu sắc, spacing, typography

> **Xem thêm:** Chi tiết về Drawer System trong `memory-bank/systemPatterns.md` (Widget Component Patterns section)

---

# MEMORY BANK FILE OPERATIONS

## Memory Bank File Operations

Memory Bank là các **FILE THỰC TẾ** trong folder `memory-bank/`, KHÔNG phải MCP tool. Tất cả operations đều thông qua file tools (`read_file`, `write`, `search_replace`, `edit_file`).

### Đọc Memory Bank Files

**BẮT BUỘC**: Trước khi bắt đầu mọi task, phải đọc TẤT CẢ các file trong `memory-bank/`:
- `memory-bank/projectbrief.md` - Tổng quan dự án
- `memory-bank/productContext.md` - Context sản phẩm
- `memory-bank/activeContext.md` - Context hiện tại
- `memory-bank/systemPatterns.md` - Patterns hệ thống
- `memory-bank/techContext.md` - Context kỹ thuật
- `memory-bank/progress.md` - Tiến độ dự án

**Cách đọc:**
- Sử dụng `read_file` tool với path đầy đủ: `memory-bank/{filename}.md`
- Đọc song song nhiều file khi có thể để tối ưu thời gian
- Ví dụ: `read_file('memory-bank/activeContext.md')`

### Cập nhật Memory Bank Files

**SAU KHI** hoàn thành code changes, phải cập nhật các file liên quan:
- `activeContext.md`: Cập nhật "Recently Completed" và "Current Sprint Focus"
- `progress.md`: Cập nhật "What works" và "Current status"
- `systemPatterns.md`: Thêm patterns mới nếu có
- `techContext.md`: Cập nhật dependencies hoặc setup nếu có thay đổi

**Cách cập nhật:**
- Sử dụng `write` tool để tạo mới file hoặc ghi đè hoàn toàn
- Sử dụng `search_replace` hoặc `edit_file` để cập nhật một phần cụ thể
- Luôn giữ format markdown nhất quán

### Lưu ý quan trọng

- Memory Bank là các **FILE THỰC TẾ** trong folder `memory-bank/`, **KHÔNG phải MCP tool**
- **KHÔNG** sử dụng MCP Memory tool cho Memory Bank
- Tất cả operations đều thông qua file tools (`read_file`, `write`, `edit_file`, `search_replace`)

---

# MEMORY BANK WORKFLOW

## Cline's Memory Bank

I am Cline, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

## Memory Bank Structure

The Memory Bank consists of core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]
    
    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC
    
    AC --> P[progress.md]

### Core Files (Required)
1. `projectbrief.md`
   - Foundation document that shapes all other files
   - Created at project start if it doesn't exist
   - Defines core requirements and goals
   - Source of truth for project scope

2. `productContext.md`
   - Why this project exists
   - Problems it solves
   - How it should work
   - User experience goals

3. `activeContext.md`
   - Current work focus
   - Recent changes
   - Next steps
   - Active decisions and considerations
   - Important patterns and preferences
   - Learnings and project insights

4. `systemPatterns.md`
   - System architecture
   - Key technical decisions
   - Design patterns in use
   - Component relationships
   - Critical implementation paths

5. `techContext.md`
   - Technologies used
   - Development setup
   - Technical constraints
   - Dependencies
   - Tool usage patterns

6. `progress.md`
   - What works
   - What's left to build
   - Current status
   - Known issues
   - Evolution of project decisions

### Additional Context
Create additional files/folders within memory-bank/ when they help organize:
- Complex feature documentation
- Integration specifications
- API documentation
- Testing strategies
- Deployment procedures

## Core Workflows

### Plan Mode
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank Files using read_file tool]
    ReadFiles --> CheckFiles{Files Complete?}
    
    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]
    
    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]

**Implementation:**
- Sử dụng `read_file` tool để đọc tất cả files trong `memory-bank/`
- Đọc song song nhiều files: `read_file('memory-bank/projectbrief.md')`, `read_file('memory-bank/activeContext.md')`, etc.
- Không sử dụng MCP Memory tool - Memory Bank là các file markdown thực tế

### Act Mode
flowchart TD
    Start[Start] --> Context[Read Memory Bank Files using read_file tool]
    Context --> Update[Update Documentation using write/search_replace]
    Update --> Execute[Execute Task]
    Execute --> Document[Update Memory Bank Files]

**Implementation:**
- Đọc các file cần thiết bằng `read_file` tool trước khi bắt đầu task
- Sau khi hoàn thành code changes, cập nhật các file liên quan bằng `write` hoặc `search_replace` tool
- Cập nhật `activeContext.md` và `progress.md` sau mỗi thay đổi quan trọng

## Documentation Updates

Memory Bank updates occur when:
1. Discovering new project patterns
2. After implementing significant changes
3. When user requests with **update memory bank** (MUST review ALL files)
4. When context needs clarification

flowchart TD
    Start[Update Process]
    
    subgraph Process
        P1[Read ALL Files using read_file tool]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Update Files using write/search_replace]
        
        P1 --> P2 --> P3 --> P4
    end
    
    Start --> Process

**How to update:**
- **Đọc files**: Sử dụng `read_file` tool với path `memory-bank/{filename}.md`
- **Cập nhật files**: Sử dụng `write` tool để ghi đè hoàn toàn hoặc `search_replace`/`edit_file` để cập nhật một phần
- **Files cần cập nhật thường xuyên**: `activeContext.md` và `progress.md` (track current state)

**Note:** When triggered by **update memory bank**, I MUST review every memory bank file using `read_file` tool, even if some don't require updates. Focus particularly on `activeContext.md` and `progress.md` as they track current state.

REMEMBER: After every memory reset, I begin completely fresh. The Memory Bank is my only link to previous work. It must be maintained with precision and clarity, as my effectiveness depends entirely on its accuracy. Memory Bank files are REAL FILES in the `memory-bank/` folder - use `read_file`, `write`, and `search_replace` tools to interact with them, NOT MCP Memory tool.

After successfully editing and writing code, update the memory bank files to correct the process using file tools.

---

# XEM THÊM

Để tìm hiểu thêm về các chủ đề cụ thể, tham khảo:

- **Context Reading Protocol:** `docs/guides/development/context-reading-protocol.md` - BẮT BUỘC đọc trước khi thực hiện task (quy trình đọc tài liệu, tuân thủ giao diện, sử dụng MCP)
- **Cấu trúc documentation:** `docs/DOCS_STRUCTURE.md` - Mô tả cấu trúc thư mục và mục đích từng file (BẮT BUỘC đọc trước khi tạo file markdown mới)
- **Cấu trúc thư mục và quy tắc tạo file:** `docs/ai/AI_INSTRUCTIONS.md` (Section 1)
- **Kiến trúc Clean Architecture & MVVM:** `docs/ai/AI_INSTRUCTIONS.md` (Section 2) và `memory-bank/systemPatterns.md`
- **MCP Usage Patterns:** `docs/ai/AI_INSTRUCTIONS.md` (Section 10) và `memory-bank/techContext.md`
- **Design System:** `memory-bank/DESIGN_SYSTEM_GUIDE.md` và `memory-bank/systemPatterns.md` (Design System Specifications section)
- **Code Conventions:** `memory-bank/activeContext.md` (Active Preferences & Standards section)
- **Technology Stack:** `memory-bank/techContext.md` - Danh sách đầy đủ thư viện và tech stack
- **Tech Stack Standards:** `.cursor/.cursorrules` (Tech Stack Standards section)
- **Current Work Focus:** `memory-bank/activeContext.md` (Current Sprint Focus section)
