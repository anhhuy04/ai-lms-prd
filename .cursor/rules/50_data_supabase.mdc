---
description: "Schema-first approach, RLS mandatory rules, complex multi-table writes via RPC, Clean Architecture data access pattern, Supabase Storage, new table checklist."
globs: ["lib/data/**/*.dart", "lib/domain/**/*.dart", "supabase/**/*", "db/**/*"]
---

# 50 — Data Layer & Supabase

## Schema First: Always Check Schema Before Coding
Before creating any model/repository/datasource:
1. Review SQL schema in `docs/note sql.txt` và migrations trong `db/`
2. Dùng **Supabase MCP** để inspect schema thực tế trên live database
3. KHÔNG assume column names (không assume `created_at` tồn tại nếu chưa check)
4. Notes về schema → ghi vào `memory-bank/README_SUPABASE.md`

```sql
-- Check via Supabase MCP execute_sql
SELECT column_name, data_type FROM information_schema.columns
WHERE table_name = 'your_table';
```

## RLS (Row Level Security) — Mandatory Rules
- **MỌI bảng** public via PostgREST PHẢI bật RLS
- Dùng `(select auth.uid())` KHÔNG dùng `auth.uid()` trực tiếp (tối ưu performance)
- Explicit policies cho từng role: **admin / teacher / student**

```sql
-- ✅ CORRECT
CREATE POLICY "teachers_read_own_classes" ON classes
  FOR SELECT USING (teacher_id = (select auth.uid()));

-- ❌ WRONG (per-row re-evaluation)
CREATE POLICY "..." ON classes
  FOR SELECT USING (teacher_id = auth.uid());
```

## Complex Multi-Table Writes — Dùng RPC
Prefer single RPC (security definer + explicit auth checks) over multiple client-side round-trips:
```dart
// ✅ Atomic multi-table write
final result = await _supabase.rpc('create_class_with_members', params: {
  'class_name': name,
  'teacher_id': teacherId,
  'member_ids': memberIds,
});
```

## Data Access Pattern (Clean Architecture)
```
UI → Provider(Riverpod) → Repository(interface) → DataSource → Supabase/Drift
```
- DataSource: raw Supabase calls, maps to Freezed models
- Repository impl: `data/repositories/`, implements `domain/repositories/` interface
- Parse heavy JSON in Isolate: `compute(() => ...)` in DataSource

## Async List Pattern (Large Lists)
```dart
// DataSource: parse in isolate
Future<List<ClassEntity>> getClasses() async {
  final raw = await supabase.from('classes').select();
  return compute(_parseClasses, raw);  // isolate
}
```

## Supabase Storage
- All storage operations: check RLS on `storage.objects` + `storage.buckets`
- Reference: `memory-bank/README_SUPABASE.md` → Storage section

## New Table Checklist (9 Steps)
1. Write schema/migration trong `db/`
2. Sync schema changes với `docs/note sql.txt`
3. Apply via Supabase MCP migration
4. Enable RLS immediately
5. Write policies cho 3 roles (admin/teacher/student)
6. Update `memory-bank/README_SUPABASE.md`
7. Create Freezed model (DTO + Entity + `toDomain()`)
8. Create DataSource + Repository
9. Run `dart run build_runner build -d`
